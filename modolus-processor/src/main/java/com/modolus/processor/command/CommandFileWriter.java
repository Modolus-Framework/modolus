package com.modolus.processor.command;

import com.modolus.annotations.command.Command;
import com.modolus.processor.ProcessorUtils;
import com.modolus.processor.command.args.ProcessorCommandArg;
import com.palantir.javapoet.*;
import org.jetbrains.annotations.NotNull;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.List;
import java.util.stream.Stream;

import static com.modolus.processor.command.Constants.*;

public final class CommandFileWriter {

    private final String packageName;
    private final TypeSpec.Builder classBuilder;
    private final List<ProcessorCommandArg> commandArgs;
    private final Command command;

    public CommandFileWriter(@NotNull String rawClassName,
                             @NotNull List<ProcessorCommandArg> commandArgs,
                             @NotNull Command command) {
        this.packageName = ProcessorUtils.getPackageName(rawClassName);
        this.commandArgs = commandArgs;
        this.command = command;

        classBuilder = TypeSpec.classBuilder(ProcessorUtils.getSimpleClassName(rawClassName))
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .superclass(getSuperclass(command));

    }

    public void write(@NotNull ProcessingEnvironment processingEnvironment) throws IOException {
        appendConstructor();
        appendFields(processingEnvironment);
        appendMethods(processingEnvironment);

        JavaFile.builder(packageName, classBuilder.build())
                .addFileComment("Generated by Modolus Command Processor")
                .build()
                .writeTo(processingEnvironment.getFiler());
    }

    private void appendMethods(@NotNull ProcessingEnvironment processingEnvironment) {
        var returnType = CommandMethods.getOverrideMethodReturnType(command);
        var parameters = CommandParameters.getOverrideMethodParameters(command);

        var overrideMethod = CommandMethods.getOverrideMethod(command)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.FINAL)
                .returns(returnType)
                .addParameters(parameters);

        var methodParams = parameters.stream()
                .map(ParameterSpec::name)
                .map(CodeBlock::of);
        var argParams = commandArgs.stream()
                .map(ProcessorCommandArg::toStatement);

        var params = Stream.concat(methodParams, argParams)
                .toList();

        var callAbstractMethod = CodeBlock.builder()
                .add("return execute(")
                .add(CodeBlock.join(params, ", "))
                .add(");");

        overrideMethod.addCode(callAbstractMethod.build());


        var abstractMethod = CommandMethods.getOverrideMethod(command)
                .setName("execute")
                .addModifiers(Modifier.ABSTRACT)
                .returns(returnType)
                .addParameters(parameters)
                .addParameters(commandArgs.stream().map(arg -> arg.toParameterSpec(processingEnvironment)).toList());


        classBuilder.addMethod(overrideMethod.build());
        classBuilder.addMethod(abstractMethod.build());
    }


    private void appendConstructor() {
        var constructorBuilder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PROTECTED)
                .addStatement("super($S, $S)", command.name(), command.description())
                .build();

        classBuilder.addMethod(constructorBuilder);
    }

    private void appendFields(@NotNull ProcessingEnvironment processingEnvironment) {
        commandArgs.stream()
                .map(arg -> arg.toFieldSpec(processingEnvironment))
                .forEach(classBuilder::addField);
    }

    private ClassName getSuperclass(@NotNull Command command) {
        return switch (command) {
            case Command c when c.target() == Command.CommandTarget.PLAYER && c.async() ->
                    ABSTRACT_ASYNC_PLAYER_COMMAND_CLASS;
            case Command c when c.target() == Command.CommandTarget.PLAYER -> ABSTRACT_PLAYER_COMMAND_CLASS;
            case Command c when c.target() == Command.CommandTarget.WORLD && c.async() ->
                    ABSTRACT_ASYNC_WORLD_COMMAND_CLASS;
            case Command c when c.target() == Command.CommandTarget.WORLD -> ABSTRACT_WORLD_COMMAND_CLASS;
            case Command c when c.async() -> ABSTRACT_ASYNC_COMMAND_CLASS;
            default -> ABSTRACT_COMMAND_CLASS;
        };
    }

}
